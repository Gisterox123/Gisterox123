# java基础

## 基础概念和常识

- jvm java虚拟机
- jre java运行环境
- jdk java开发环境



java程序从源代码到运行的过程:

.java ----->  javac  ----->  .class -----> 解释器（JIT 运行时编译  AOT）----->机器码 ----->  os



编译型语言---> 编译器（一次性编译完毕）---->机器码 ------os

解释型语言---->解释器 （一句一句解释） ----> 机器码------os

java ----javac 编译 -----字节码------解释----机器码 ----os运行



### continue break return

- continue 跳出当次循环，继续下一次循环
- break 跳出整个循环体，继续下面的代码
- return 结束当前方法

### 基本数据类型

| 类型    | 大小(1字节 = 8 位数)-             | 默认值  |
| ------- | --------------------------------- | ------- |
| boolean | 官方文档未定义大小，依赖于jvm实现 | false   |
| byte    | 1                                 | 0       |
| short   | 2                                 | 0       |
| int     | 4                                 | 0       |
| long    | 8                                 | 0L      |
| float   | 4                                 | 0f      |
| double  | 8                                 | 0d      |
| char    | 2                                 | "u0000" |

1. char a ='a';   
2. String b = "adcd";
3. 对应的包装类默认值为null
4. 基本类型存放在虚拟机栈中，包装类型属于对象存在于堆中

####  包装类型的常量池技术

byte short integer long 四种默认创建[-128-127]的相应缓存数据

Character 创建了[0,127]的缓存数据

Boolean 直接返回true，false

所有整型包装类对象之间值的比较，全部使用 equals 方法比较

## 面向对象基础

封装，继承，多态

* 继承： 子类拥有父类的所有属性和方法，父类的私有方法和属性无法无法访问。**只是拥有**

* 多态：多态不能调用"子类存在父类不存在的"方法

#### 深拷贝 浅拷贝 引用拷贝

引用拷贝：引用地址

浅拷贝：在堆上创建一个新对象，内部是引用类型则引用地址

深拷贝：完全复制整个对象，引用类型也是

#### java常见对象

##### Object

```java
public final native Class<?> getClass(); //当前对象的class对象
public native int hashCode();//对象的哈希码。主要使用在哈希表中
public Boolean equals(Object obj);//内存地址。子类一般重写比较内容
protect native Object clone();//并返回当前对象的一份拷贝。对于任何对象x，x.clone()!=x为true,x.clone().getClass()==x.getClass()为true
public String toString();//返回类名@实例的哈希码的16进制字符串。子类都重写
protect void finalize() throws Throwable{};//实例被垃圾回收时触发
public final native notify();//随即唤醒一个锁阻塞的线程
public final native notifyAll();//唤醒所有的线程
public final void wait(long timeout,int nanos) throws InterruptedExeception;//释放锁，等待nanos表示额外时间，单位豪微妙
public final void wait(long timeout) throws InterruptedExeception;
public final void wait() throws InterruptedExeception;
```

#### String

* String final不可变，少量数据
* Stringbuffer  有缓冲，大量数据线程安全
* Stringbuilder 有缓冲，大量数据，线程不安全

对象引用和“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的

在循环内使用"+"进行拼接的话，编译器不会创建单个StringBuilder对象

#### 字符串常量池

```java
String aa = "ab";//放入常量池
String bb = "ab";//常量池获取
System.out.print(aa==bb);//true
```

#### 泛型

通过反射可以添加多类型的数据，java泛型在运行期间都会被*擦除*

* 泛型类

  ```java
  public class Generic<T>{
      private T key;
      public Generic(T key){
          this.key = key;
      }
      public T getKey(){
          return key;
      }
  }
  
  Generic<Integer> int = new Generic<>(123456);
  ```

  

* 泛型接口

  ```java
  public interface Gereric<T>{
      public T method();
  }
  
  class GenericImpl<T> implements Generic<T>{
      @Override
      public T method(){
          return null;
      }
  }
  
  public GeneratorImpl implements GenericImpl<String>{
      @Override
      public String method(){
          return "HELLO";
      }
  }
  ```

* 泛型方法

```java
public static <E> void printArray(E[] inputArray){
    for(E element : inputArray) {
        System.out.printf("%s ", element);
    }
    System.out.println();
}


Int[] intArray = {1,2,3,4};
String[] stringArray = {"Hello","world"};
printArray(intArray);
printArray(stringArray);

```

通配符：T     E    K    V  ?

T(type)  表示一个具体的类型

K V （key,value） java的键值对

E(element)  

?   表示不确定的类型



## 异常

|                    | Throwable             |                                    |
| ------------------ | --------------------- | ---------------------------------- |
| **Error**          | **Exception**         |                                    |
|                    | **IOException**       | **RunTimeException**(不受检查异常) |
| OutofMemoryError   | EOFException          | ArithmaticException                |
| stackOverFlowError | FileNotFoundException | NullPointerException               |
| LinkageError       | UnknownHostException  | IndexOutOfBoundException           |
|                    | IntruptedException    | ClassCastException                 |
|                    |                       | ArrayIndexOutOfBoundsException     |
|                    |                       | IlleagalArgumentException          |
|                    |                       | NoSuchElementException             |

Throwable 类的方法：

- `String getMessage()`: 返回异常发生时的简要描述
- `String toString()`: 返回异常发生时的详细信息
- `String getLocalizedMessage()`: 返回异常对象的本地化信息。使用 `Throwable` 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 `getMessage()`返回的结果相同
- `void printStackTrace()`: 在控制台上打印 `Throwable` 对象封装的异常信息



#### try-catch-finally 

* 不要在finally语句块中使用return. 当try和finally语句中都有return时，finally中的return不会执行
* 当线程死亡和cpu关闭时，finally语句块中的代码不会执行

```java
//使用try-with-resources代替try-catch-finally

//y-catch-finally
Scanner sc = null;
try{
    sc = new Scanner(new File("D://read.txt"));
    while(sc.hasNext()){
        System.out.println(sc.nextLine());
    }
}catch(FileNotFoundExeception e){
    e.printStackTrace();
}finally{
    if(sc != null){
        sc.close();
    }
}

// try-with-resources
try(Scanner sc = new Scanner(new File("test.txt")){
    while(sc.hasNext()){
        System.out.println(sc.nextLine());
    }
}catch(FileNotFoundException e){
    e.printSackTrace();
}
    //当有多个资源需要关闭时使用";"分隔
```



